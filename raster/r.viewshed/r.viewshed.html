<h2>DESCRIPTION</h2>

<p><em>r.viewshed</em> is a module that computes the viewshed of a
point on a raster terrain. That is, given an elevation raster, and the
location of an observer, it generates a raster output map showing
which cells are visible from the given location. 

The algorithm underlying <em>r.viewshed</em> minimizes both the CPU
operations and the transfer of data between main memory and disk; as a
result <em>r.viewshed</em> runs fast on very large rasters.

<h3>Options and flags:</h3>

To run <em>r.viewshed</em>, the user must specify an input map name,
an output map name, and the location of the viewpoint.  

<p>Viewpoint (<em>coordinate</em> parameter): For the time being the viewpoint
is assumed to be located inside the terrain.  The viewpoint location is
given in map coordinates.

<p>Output: The output map may have one of three possible formats,
based on which flags are set.

<p>
By default, if no flag is set, the output is in angle-mode, and
each point in the output map is marked as NULL if the point is not
visible or the respective point in the elevation map is NULL.

Otherwise, a value in [0, 180] representing the vertical angle with
regard to the viewpoint, in degrees, if the point is visible.
0 degrees: directly above the observer,
180 degrees: directly below the observer

<p>
If the <b>-b</b> flag is set, the output is in boolean-mode, and each point
in the output map is marked as:
<ul>
  <li> 0 if the point is Nodata/null or not visible
  <li> 1 if the point is visible.
</ul>


<p>
If the <b>-e</b> flag is set, the output is in elevation-mode, and each point
in the output map is marked as:
<!-- Check & FIXME -->
<ul>
  <li> Nodata (null), if the respective point in the elevation map is Nodata (null) 
  <li> -1, if the point is not visible
  <li> the difference in elevation between the point and the viewpoint, if the point is visible.
</ul>

<p>
If you wish to identify the area of the map which is within the search
radius but not visible, a combination of <em>r.buffer</em> and
<em>r.mapcalc</em> can be used to create a negative of the viewshed map.



<p>
Curvature of the earth: By default the elevations are not adjusted for
the curvature of the earth. The user can turn this on with flag
<b>-c</b>.

<p>
Observer elevation: By default the observer is assumed to have
height=0 above the terrain.  The user can change this using option
<em>obs_elev=...</em>. The value entered is in the same units
as the elevation.

<p>
Target elevation: By default the target is assumed to have
height=0 above the terrain.  The user can change this using option
<em>tgt_elev=...</em> to determine if objects of a given height would be 
visible. The value entered is in the same units as the elevation.

<p>
Maximum visibility distance: By default there is no restriction on
the maximum distance to which the observer can see.  The user can set
a maximum distance of visibility using option <em>max_dist=...</em>.
The value entered is in the same units as the cell size of the raster.

<p>
Main memory usage: By default <em>r.viewshed</em> assumes it has
500MB of main memory, and sets up its internal data structures so that
it does not require more than this amount of RAM.  The user can set
the amount of memory used by the program by setting the
<em>memory_usage</em> to the number of MB of memory they would like to
be used.


<h3>Memory mode</h3>

The algorithm can run in two modes: in internal memory, which
means that it keeps all necessary data structures in memory during the
computation. And in external memory, which means that the data
structures are external, i.e. on disk.  <em>r.viewshed</em> decides
which mode to run in using the amount of main memory specified by the
user.  The internal mode is (much) faster than the external mode.

<p>
Ideally, the user should specify on the command line the amount of
physical memory that is free for the program to use. Underestimating
the memory may result in <em>r.viewshed</em> running in external mode
instead of internal, which is slower. Overestimating the amount of
free memory may result in <em>r.viewshed</em> running in internal mode
and using virtual memory, which is slower than the external mode.




<h3>The algorithm:</h3>

<em>r.viewshed</em> uses the following model for determining
visibility: The height of a cell is assumed to be variable, and the 
actual height of a point falling into a cell, but not identical the cell 
center, is interpolated. Thus the terrain is viewed as a smooth surface. 
Two points are visible to each other if their line-of-sight does not
intersect the terrain. The height for an arbitrary point x in the terrain 
is interpolated from the 4 surrounding neighbours. This means that this 
model does a linear (bilinear) interpolation of heights.

This model is suitable for both low and high resolution rasters as well 
as terrain with flat and steep slopes.

<p>The core of the algorithm is determining, for each cell, the
line-of-sight and its intersections with the cells in the terrain. For
a (square) grid of <em>n</em> cells, there can be <em>O(n
<sup>1/2</sup>)</em> cells that intersect the LOS. If we test every
single such cell for every point in the grid, this adds up to
<em>O(n<sup>3/2</sup>)</em> tests. We can do all these tests faster if
we re-use information from one point to the next (two grid points that
are close to each other will be intersected by a lot of the same
points) and organize the computation differently.

<p>More precisely, the algorithm uses a technique called <em>line
sweeping</em>: It considers a half-line centered at the viewpoint, and
rotates it radially around the viewpoint, 360 degrees.  During the
sweep it keeps track of all the cells that intersect the sweep line at
that time; These are called the <em>active</em> cells. A cell has 3
associated events: when it is first met by the sweep line and inserted
into the active structure; when it is last met by the sweep line and
deleted from the active structure; and when the sweep line passes over
its centerpoint, at which time its visibility is determined.  To
determine the visibility of a cell all cells that intersect the
line-of-sight must be active, so they are in the active structure.
The algorithm looks at all the active cells that are between the point
and the viewpoint, and finds the maximum gradient among these.  If the
cell's gradient is higher, it is marked as visible, whereas if it is
lower, it is marked as invisible.

<p>For a (square) raster of <em>n</em> point in total, the standard
viewshed algorithm uses <em>O(n sqrt(n))= O(n<sup>3/2</sup>)</em>
time, while the sweep-line algorithm uses <em>O(n lg n)</em> time.
This algorithm is efficient in terms of CPU operations and can be also
made efficient in terms of I/O-operations.  For all details see the
REFERENCES below.


<p>
<table width=50% align=center>
  <tr>
      <th><img src="sweep1.png" width=200 alt="[SDF]" border=0></th>
      <th><img src="sweep2.png" width=200 alt="[SDF]" border=0></th>
  </tr>
  <tr>	
    <th>The sweep-line.</th>
    <th>The active cells.</th>
  </tr> 
</table>


<h3>An example:</h3>


Using the Spearfish dataset:  calculating the viewpoint from the top
of a mountain:

<div class="code"><pre>
g.region rast=elevation.10m
r.viewshed input=elevation.10m output=viewshed coordinate=598869,4916642 mem=800
</pre></div>


<h3>REFERENCES</h3>

<ul>

   <li>Computing Visibility on Terrains in External Memory. Herman
	 Haverkort, Laura Toma and Yi Zhuang. To appear in <em>ACM Journal
	 on Experimental Algorithmics</em>.
	 
	 <li><a
	 href="http://www.siam.org/proceedings/alenex/2007/alx07_002haverkorth.pdf">
	 Computing Visibility on Terrains in External Memory</a>. Herman
	 Haverkort, Laura Toma and Yi Zhuang. In the <em>Proceedings of
	 the 9th Workshop on Algorithm Engineering and Experiments /
	 Workshop on Analytic Algorithms and Combinatorics (ALENEX/ANALCO
	 2007)</em>.</li>

</ul>

<h3>AUTHORS</h3>

<p>Laura Toma (Bowdoin College): <tt>ltoma@bowdoin.edu</tt>
<p> Yi Zhuang (Carnegie-Mellon University): <tt>yzhuang@andrew.cmu.edu</tt>
<p>William Richard (Bowdoin College): <tt>willster3021@gmail.com </tt>
<p>Markus Metz

<p>
<i>Last changed: $Date$</i>
