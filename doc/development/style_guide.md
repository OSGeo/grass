# GRASS Programming Style Guide

## Code Style and Formatting

### Python

We follow the [PEP8](http://www.python.org/dev/peps/pep-0008/) style guide for
Python. Docstrings follow [PEP257](http://www.python.org/dev/peps/pep-0257/) and
use
[Sphinx style](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html).

We use the following tools in the continuous integration to ensure compliance
with PEP8, consistent formatting, and readable and error-free code:

- [flake8](https://flake8.pycqa.org/en/latest/) tool to ensure compliance with
  PEP8
- [black](https://black.readthedocs.io/en/stable/) code formatter to ensure
  consistent code formatting
- [pylint](https://pylint.readthedocs.io/en/latest/) static code analyser to
  find bad code practices or errors

Note that while the entire GRASS code base is black formatted, full complience
with PEP8 is still work in progress.

It is highly recommended to install and use [pre-commit](https://pre-commit.com)
before submitting any new or modified code or any other content. The pre-commit
Git hooks set checks validity and executes automated formatting. See
[Submitting document](submitting.md) for pre-commit setup and usage.

#### Black

Use Black to format files:

```bash
black {source_file_or_directory}
```

Black is configured via [pyproject.toml](../../pyproject.toml). Default line
length is 88 characters.

#### Flake8

Use Flake8 to check formatting of all files:

```bash
flake8 python_file.py
```

The root directory contains [.flake8](../../.flake8) configuration file which
contains a less strict configuration for legacy code. It will be used by default
when running flake8 within GRASS source code. From outside, you can point to it
with `--config` pararameter:

```bash
flake8 --config  {path_to_flake8_file} {path_to_python_file}
```

Alternatively, you can explicitely specify which errors or warnings to ignore:

```bash
flake8 --ignore=E203,E266,E501 --max-line-length=88 python_file.py
```

### C and C++

C and C++ code is formatted with
[ClangFormat](https://clang.llvm.org/docs/ClangFormat.html). Contributions are
expected to be formatted with `clang-format` (currently with version 15+). The
most convenient method to install clang-format and format files is
[using pre-commit](./submitting.md#use-pre-commit).

Alternatively, using separately installed clang-format on modified files:

```bash
clang-format -i <new_or_modified_file.c>
```

The ClangFormat settings for the repo are defined in
[.clang-format](../../../.clang-format).

If using pre-commit is not an option, for whatever reason, there is a helper
script [grass_clang_format.sh](./utils/grass_clang_format.sh), which simplifies
bulk reformatting.

## Documentation

There are three types of documentation: C API, Python API and tool manual pages.

### C API documentation

We
[​use doxygen and document the functions](https://grass.osgeo.org/programming8/)
directly in the source code. See lib/gis/\*.c and lib/gis/gislib.dox for
examples.

### Python API documentation

Python API documentation is written in reStructuredText which is compiled with
Sphinx (see
[​PyGRASS documentation](https://grass.osgeo.org/grass-stable/manuals/libpython/pygrass_index.html))

```python
def func(arg1, arg2):
    """Summary line.

    Extended description of function.

    :param int arg1: Description of arg1.
    :param str arg2: Description of arg2.
    :raise: ValueError if arg1 is equal to arg2
    :return: Description of return value
    :rtype: bool

    :example:

    >>> a=1
    >>> b=2
    >>> func(a,b)
    True
    """

    if arg1 == arg2:
        raise ValueError('arg1 must not be equal to arg2')

    return True
```

See
[Sphinx docstring format](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html)
for more details.

### Tool documentation

Documentation of a tool should come with clear descriptions, hints on the
implemented algorithm and example(s) with figures.

Each tool (also called "module") comes with its own manual page written in
simple HTML. The HTML file contains **no header nor footer**. The complete HTML
file is autogenerated during the compilation process (with --html-description
parameter). In order to make sure that manuals build without issues, it can be
useful to validate the HTML before submitting, e.g. here:
[​https://validator.w3.org/](https://validator.w3.org/)

Name the documentation file `'<tool>.html'`, e.g., if the tool is named
r.example, the documentation file should be named `r.example.html`.

#### Markup style guide

The structure consists of several required and optional sections:

```html
<h2>DESCRIPTION</h2>
<!-- required -->

<h2>NOTES</h2>
<!-- suggested -->

<h2>EXAMPLES</h2>
<!-- suggested -->

<h2>TODO</h2>
<!-- optional -->

<h2>KNOWN ISSUES</h2>
<!-- optional -->

<h2>REFERENCES</h2>
<!-- optional -->

<h2>SEE ALSO</h2>
<!-- required -->

<h2>AUTHORS</h2>
<!-- required -->
```

Note that HTML is converted to MAN pages by
[tools/g.html2man/](https://trac.osgeo.org/grass/browser/grass/trunk/tools/g.html2man).
Since the MAN conversion is limited, please use no other HTML tags than:

```html
<a> <b> <body> <br> <code> <dd> <dl> <dt> <em>
<h2> <h3> <h4> <head> <hr> <i> <img> <li> <ol> <p>
<pre> <sup> <table> <td> <th> <title> <tr> <ul>
```

More notes on markup:

- Tool names (i.e., v.category) should be emphasized with `<em>v.category</em>`.
- Flags and parameter names written in boldface like `<b>-f</b>` and
  `<b>input</b>`.
- Shell commands, names, values, etc. should use `<tt>42</tt>`.
- Emphasized phrases `<i>should use italics</i>`.
- In order to minimize potential git merge conflicts, please break a line at
  approximately 70-80 chars.

Examples should be coded like this:

```html
<div class="code">
  <pre>
v.to.db map=soils type=area option=area column=area_size unit=h
</pre
  >
</div>
```

The `<h2>SEE ALSO</h2>` section of each page should be alphabetized:

```html
<em>
  <a href="d.shade.html">d.shade</a>, <a href="g.region.html">g.region</a>,
  <a href="r.shade.html">r.shade</a>
</em>
```

#### Images

Naming convention: `tool_name.png` or `tool_name_keyword.png` (in both cases,
dots in module name are replaced by underscores)

Examples:

- `d_geodesic.png`
- `r_resamp_stats_6m_20m.png`
- `g_gui_rlisetup_8.png`
- `v_clean_rmsa.png`

Image size: ideally **600 pixel width** (height depends on that), use e.g.
ImageMagic:

```bash
mogrify -resize 600x file.png
```

Smaller images are also possible when appropriate, e.g. when a lot of images are
included or they are something special, e.g. equations, icons or simple
diagrams. Larger images are supported, too, see below for an optimal inclusion
into the HTML page.

Please **compress** PNG images with:

```bash
# color quantization
# optional, but usually worth it
# note: may change colors
pngnq -n 128 -s 3 file.png

# shuffle original and quantitized image names
mv file.png file_ORIG.png
mv file-nq8.png file.png

# compress better (lossless)
optipng -o5 file.png
```

Format: Images should be ideally in PNG (well, JPG and GIF is allowed as well
when appropriate but usually it is not!). Vector graphics should be included in
pages as raster images (i.e. PNGs) for portability but the original format
(preferably SVG) should be committed to the repository as well.

Adding the image to the HTML page (r.viewshed example, the screenshot is shown
with a width of 600 pixel but it is clickable in the manual page). If a larger
image is displayed as shrunk, both **width** and **height** HTML parameters
(values must be calculated according to the picture size!) should be set:

```html
<div align="center" style="margin: 10px">
  <a href="r_viewshed.png">
    <img
      src="r_viewshed.png"
      width="600"
      height="600"
      alt="r.viewshed example"
      border="0"
    /> </a
  ><br />
  <i
    >Figure: Viewshed shown on shaded terrain (observer position in the
    north-east quadrant with white dot; 5m above ground)</i
  >
</div>
```

## Best Practices

### General

#### Computational Region

Tools typically **do not change the computational region based on the input
data**. Raster processing tools should respect the current computational region.
Vector processing tools may use the current computational region, e.g., to
selected subset of the input data.

**Why?** Users should be able to re-run a command or workflow with different
computational regions to, e.g., test processing in a small are and then move to
a larger one. Also, changing the current region globally can break parallel
processing.

**Exceptions**: Tools importing data typically import entire dataset, respecting
of the region may be implemented as an optional feature (e.g., r.in.gdal). This
is to avoid, e.g., importing data under finer resolution than the native
resolution of the data. Another exception is raster processing where alignment
of the cells plays a crucial role and there is a clear answer to how the
alignment should be done. In that case, the tool may change the resolution. Some
tools, such as r.mapcalc, opt for providing additional computation region
handling policies. Finally, some operations are meant use all the data, e.g.,
creating metadata, these operations should not use the current computational
region.

If you need to change the computational region, there are ways to change it only
within your script, not affecting the current region.

#### Mapsets

**Output data should be always written to the current mapset**. This is ensured
by build-in GRASS mechanisms, so there is nothing which needs to be done in the
tool. If a tool modifies inputs, the input must be in the current mapset.

The tool should accept inputs from any mapset in the current project. The
user-provided name **may or may not include mapset name** and the tool needs to
respect that.

#### Input and Output Geospatial Data Format

A analytical tool should read and write geospatial data as GRASS raster or
vector maps. Importing data from other formats should be left to dedicated
import and export tools, e.g., _v.import_. The obvious exceptions are import and
export of data, e.g., _r.in.xyz_.

The processing and analytical tools can then use simple names referring to the
data in GRASS project instead of file paths. This follows separation of
concerns: format conversion and CRS transformations are separate from analysis.

#### Overwriting Existing Data

A tool should not overwrite existing data unless specified by the user using the
`--overwrite` flag. The GRASS command line parser automatically checks for
output data (raster, vector maps) existence and ends the tool execution with a
proper error message in case the output already exists. If the flag is set by
the user (`--overwrite` in command line, `overwrite=True` in Python), the parser
enables the overwriting for the whole tool.

The `--overwrite` flag can be globally enabled by setting environment variable
`GRASS_OVERWRITE` to 1. Notably, the GRASS session from _grass.jupyter_ sets
`GRASS_OVERWRITE` to 1 to enable re-running of the cells and notebooks.

#### Mask

GRASS GIS has a global mask managed by the _r.mask_ tool and represented by a
raster called MASK. Raster tools called as a subprocess will automatically
respect the globally set mask when reading the data. For outputs, respecting of
the mask is optional.

Tools **should not set or remove the global mask**. If the tool cannot avoid
setting the mask internally, it should check for presence of the mask and fail
if the mask is present. The tools should not remove and later restore the
original mask because that creates confusing behavior for interactive use and
breaks parallel processing.

Generally, any mask behavior should be documented unless it is the standard case
where masked cells do not participate in the computation and are represented as
NULL cells (no data) in the output.

### Best practices when writing Python scripts

#### Import Python Scripting Library

```python
import grass script as gs

gs.run_command(...)
```

#### String formatting

User messages should be translatable and for formatting, use `str.format()`, not
f-strings:

```python
gs.warning(_("Raster map <{}> not found.").format(input_map))
```

For strings that are not translatable, use f-strings:

```python
r_mapcalc_expression = f"{output_map} = {input_map} * 3"
```

#### Temporary files

To create a temporary file, use `NamedTemporaryFile` with a context manager. In
this example, we open a temporary file for writing, write something and then we
can use it in another tool. Once we do not need it anymore, we need to delete it
ourselves.

```python
import tempfile

with tempfile.NamedTemporaryFile(mode="w", delete=False) as tmp_file:
    file_path = tmp_file.name
    tmp_file.write(...)

gs.try_remove(file_path)
```

#### Changing computational region

If a tool needs to change the computational region for part of the computation,
temporary region in Python API is the simplest way to do it:

```python
gs.use_temp_region()  # From now on, use a separate region in the script.
# Set the computational region with g.region as needed.
grass.run_command('g.region', raster='input')
gs.del_temp_region()
# Original region applies now.
```

This makes any changes done in the tool local for the tool without influencing
other tools running in the same session.

If you need even more control, use the GRASS_REGION environment variable which
is passed to subprocesses. Python API has functions which help with the setup:

```python
os.environ["GRASS_REGION"] = gs.region_env(raster=input_raster)
```

If different subprocesses need different regions, use different environments:

```python
env = os.environ.copy()
env["GRASS_REGION"] = gs.region_env(raster=input_raster)
gs.run_command("r.slope.aspect", elevation=input_raster, slope=slope, env=env)
```

This approach makes the computational region completely safe for parallel
processes as no region-related files are modified.

#### Temporary Maps

Using temporary map is preferred over using temporary mapsets. This follows the
rule that writing should be done only to the current mapset. Some users may have
write permissions only for their mapsets, but not for creating other mapsets.

The following script creates a temporary name using append_node_pid which is
using node (computer) name and process identifier to create unique, but
identifiable name. The temporary maps are removed when scripts ends that's to
adding the removal function to exit procedures using atexit.register.

```python
import atexit

import grass.script as gs


def remove(name):
    gs.run_command(
        "g.remove", type="raster", name=name, flags="f", quiet=True, errors="ignore"
    )


def main():
    temporary = gs.append_node_pid("tmp_mapcalc")
    atexit.register(remove, temporary)

    gs.mapcalc(f"{temporary} = rand(1, 10)")


if __name__ == "__main__":
    main()
```

#### Checking inputs of a tool

Use gs.findfile() when there is a need to test if a map exists.

```python
# test for input raster map
result = gs.find_file(map_name, element='raster')
if not result['file']
    gs.fatal(_("Raster map <{}> not found").format(map_name))

# test for input vector map
result = gs.find_file(map_name, element='vector')
if not result['file']
    gs.fatal(_("Vector map <{}> not found").format(map_name))
```

Tools need to accommodate input map names with (_elevation_) and without mapset
(_elevation@PERMANENT_). If you need only the map name without mapset, you can
do:

```python
map_name = map_name.split("@")[0]
```

If you need the full name or the mapset only, use _gs.findfile_:

```python
file_info = gs.find_file(map_name, element="raster")
full_name = file_info["fullname"]
name = file_info["name"]
mapset = file_info["mapset"]
```

#### Messages

For any informational output, use the _gs.message_ function or _gs.verbose_. For
error messages should be used _gs.fatal_ (ends execution) or _gs.error_ (just
prints error) and for warnings _gs.warning_. For debugging purposes use
_gs.debug_.

```py
# normal message:
gs.message(_("Done"))

# verbose message:
gs.verbose(_("Computation finished successfully"))

# warning:
gs.warning(_("No input values found, using default values"))

# error:
gs.error(_("No map found"))

# fatal error:
# prints error and exits or raises exception (use set_raise_on_error to set the behavior)
gs.fatal(_("No map found, exiting"))

# debug output (use g.gisenv to enable/disable)
# debug level is 1 to 5 (5 is most detailed)
gs.debug(_("Our calculated value is: {}".format(value), 3)
```

Do not use the `print` function for informational output. This is reserved for
standard module output if it has one.

### Best practices for GRASS Addons

#### Use Standard Options in Interface

GRASS tools must use the GRASS parser to handle its command line parameters. To
make writing parameters simpler and the interfaces more unified, use standard
options. See
[Parser standard options](https://grass.osgeo.org/grass82/manuals/parser_standard_options.html).
For example, use this:

```python
# %option G_OPT_V_INPUT
# %end
# %option G_OPT_R_OUTPUT
# %end
```

If needed, override values which need to be different:

```python
# %option G_OPT_V_INPUT
# % key: point_input
# % label: Name of input vector map with points
# % description: Points which used for sampling the raster input
# %end
# %option G_OPT_R_OUTPUT
# % key: raster_input
# % label: Name of sampled raster map
# % description: Raster map which will be sampled by the points
# %end
```

Do not repeat the values when a standard option defines them.

#### Consider both Flags and Options to modify behavior

Flags are like options which are booleans with default false with names which
are only one character. They are defined using:

```python
# %flag
# % key: n
# % description: Consider zeros to be null values
# %end
```

On the command line, the flag is used with dash as `-n`. In Python, the flag
would be used in the _flags_ parameter of `run_command``:

```python
gs.run_command(..., flags="n", ...)
```

However, options are often better because they improve readability, clarify the
default behavior, and allow for extension of the interface.

**Example:** Consider a tool which produces text output which by default
produces human-readable plain text output. Then you add JSON output which is
enabled by a flag `j`. Later, you decide to add YAML output. This now needs to
be flag y which needs to be exclusive with flag `j`. Soon, you have several
related flags each exclusive with all the others. Using an option instead of
flag from the beginning allows the interface to accommodate more formats. In
this example, an option named `format` can have default value `plain` and `json`
from JSON output. When you later add YAML, you simply add `yaml` to possible
values without a need for additional options or flags. The interface definition
for the example would look like:

```python
# %option
# % key: format
# % type: string
# % required: yes
# % options: plain,json,yaml
# % label: Output format
# % descriptions: plain;Plain text output;json;JSON output;yaml;YAML output
# % answer: plain
# %end
```

#### Adding description and keywords

Each tool needs to have a description and at least 3 keywords:

<!-- markdownlint-disable line-length -->

```python
# %module
# % label: Generates a raster map using gaussian random number generator.
# % description: Mean and standard deviation of gaussian deviates can be expressed by the user.
# % keyword: raster
# % keyword: surface
# % keyword: random
# %end
```

<!-- markdownlint-enable line-length -->

Notes:

- the **first** keyword is the module family which goes to the
  [module family index](https://grass.osgeo.org/grass-stable/manuals/general.html)
  in the manual
- the **second** keyword is the overall topic which goes to the
  [topic index](https://grass.osgeo.org/grass-stable/manuals/topics.html) in the
  manual
- the **third** (and more) keyword goes to the
  [keyword index](https://grass.osgeo.org/grass-stable/manuals/keywords.html) in
  the manual

These index manual pages are autogenerated during the build process of GRASS
GIS.

#### Lazy import of optional dependencies

For optional dependencies, import only after the _gs.parser_ call. That way the
tool can be safely compiled even if the dependency is not installed.

```python
def main():
    options, flags = gs.parser()
    try:
        import pandas as pd  # noqa: E402
    except ModuleNotFoundError:
      gs.fatal(_("Pandas library not installed"))
```

#### Tool name

Try to use names which describe shortly the intended purpose of the tool.

The first letters for the tool name should be:

```text
d.    - display commands
db.   - database commands
g.    - general GIS management commands
i.    - imagery commands
m.    - miscellaneous tool commands
ps.   - postscript commands
r.    - raster commands
r3.   - raster3D commands
v.    - vector commands
```

Some additional naming conventions

- export modules: (type).out.(format) eg: _r.out.arc_, _v.out.ascii_
- import module: (type).in.(format) eg: _r.in.arc_, _v.in.ascii_
- conversion modules: (type).to.(type) eg: _r.to.vect_, _v.to.rast_,
  _r3.to.rast_

Avoid module names with more than two dots in the name. Example: instead of
_r.to.rast3.elev_ use _r.to.rast3elev_.

#### Data processing history

Tools should record processing history to the output data. For vectors:

```python
gs.vector_history(output)
```

For rasters:

```python
gs.raster_history(output, overwrite=True)
```

### Best practices for GRASS GUI

Follow
[wxPython style guide](https://wiki.wxpython.org/wxPython%20Style%20Guide).

Please use the following docstring template:

```py
"""!
@package dir.example

@brief Short example package description

Classes:
 - example::ExampleClass

(C) 2024 by the GRASS Development Team

This program is free software under the GNU General Public License
(>=v2). Read the file COPYING that comes with GRASS for details.

@author First Author <first somewhere.com>
@author Second Author <second somewhere.com>
@author Some Other <third somewhere.com> (some particular change)
"""
```

#### Translations

To enable translating of messages to other languages, use full strings, e.g.
(good example):

```python
if ...:
    win.SetLabel(_("Name for new 3D raster map to create"))
else:
    win.SetLabel(_("Name for new raster map to create"))
```

instead of constructing string from several parts (bad example):

```python
if ...:
    maplabel = 'raster map'
else:
    maplabel = '3D raster map'
win.SetLabel(_("Name for new {} to create").format(maplabel))
```

Sometimes the string might have different translation depending on the context
(is it a verb or a noun? matching ending of a word for particular gender; etc).
To help translators, it is suggested to add a comment explaining the context of
string. The comment must start with GTC keyword and must be on a line before
string:

```python
self.bwizard = wx.Button(...,
    # GTC New location
    label = _("N&ew"))

# GTC %s will be replaced with name of current shell
gs.message(_("Running through {}").format(shellname))
```
